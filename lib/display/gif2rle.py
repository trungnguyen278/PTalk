#!/usr/bin/env python3
"""
gif2rle.py
Convert GIF (or any image sequence supported by Pillow) to an RLEAnimation C header.

Outputs a header file that defines:
 - RLESegment arrays (per frame)
 - RLEFrame array
 - RLEAnimation struct named as given (--name)

Usage:
    pip install pillow
    python gif2rle.py input.gif out_anim.hpp --name my_anim --width 240 --height 240

Notes:
 - The converter forces runs to end at row boundaries (no segment crosses rows).
 - Runs are stored as (count,color) pairs where color is uint16_t RGB565.
 - If a run length exceeds uint16_t, that's unlikely (max width <= 65535). We also
   clamp runs to row width to keep count <= width.
"""
import sys
import argparse
from PIL import Image, ImageSequence
import os

def rgb888_to_rgb565(r, g, b):
    return ((r & 0xF8) << 8) | ((g & 0xFC) << 3) | (b >> 3)

def process_frame(img, target_w, target_h):
    # Resize/pad image to target size
    if img.size != (target_w, target_h):
        img = img.convert("RGBA")
        img = img.resize((target_w, target_h), Image.LANCZOS)
    else:
        img = img.convert("RGB")

    pixels = img.load()
    segments = []
    for y in range(target_h):
        run_color = None
        run_len = 0
        for x in range(target_w):
            r,g,b = pixels[x, y][:3]
            color565 = rgb888_to_rgb565(r,g,b)
            if run_color is None:
                run_color = color565
                run_len = 1
            elif color565 == run_color:
                run_len += 1
            else:
                segments.append((run_len, run_color))
                run_color = color565
                run_len = 1
        # finish row
        if run_len > 0:
            segments.append((run_len, run_color))
    return segments

def write_header(frames_segments, width, height, outpath, name):
    # frames_segments: list of lists of (count, color)
    with open(outpath, "w") as f:
        guard = os.path.splitext(os.path.basename(outpath))[0].upper() + "_H"
        f.write(f"#ifndef {guard}\n#define {guard}\n\n")
        f.write('#include "RLEAnimation.hpp"\n#include <cstdint>\n\n')
        f.write("// Auto-generated by gif2rle.py\n\n")
        total_frames = len(frames_segments)

        frame_names = []
        for i, segs in enumerate(frames_segments):
            seg_arr_name = f"{name}_frame{i}_segments"
            frame_names.append((seg_arr_name, len(segs)))
            f.write(f"static const RLESegment {seg_arr_name}[] = {{\n")
            # each seg as {count, color}, write hex color
            for (count, color) in segs:
                f.write(f"    {{ {count}, 0x{color:04X} }},\n")
            f.write("};\n\n")

        # RLEFrame arrays (we will create one array of frames)
        f.write(f"static const RLEFrame {name}_frames[] = {{\n")
        for i, (seg_name, seg_count) in enumerate(frame_names):
            f.write(f"    {{ {seg_name}, {seg_count} }},\n")
        f.write("};\n\n")

        # RLEAnimation object
        f.write(f"static const RLEAnimation {name} = {{\n")
        f.write(f"    {name}_frames,\n")
        f.write(f"    (uint16_t){total_frames},\n")
        f.write(f"    (uint16_t){width},\n")
        f.write(f"    (uint16_t){height}\n")
        f.write("};\n\n")

        f.write(f"#endif // {guard}\n")
    print(f"Wrote {outpath} with {total_frames} frames")

def main():
    p = argparse.ArgumentParser(description="Convert GIF/frames to RLEAnimation header")
    p.add_argument("input", help="input gif or image")
    p.add_argument("output", help="output header .hpp")
    p.add_argument("--name", "-n", required=True, help="C identifier name for animation")
    p.add_argument("--width", type=int, default=240, help="target width")
    p.add_argument("--height", type=int, default=240, help="target height")
    args = p.parse_args()

    im = Image.open(args.input)
    frames_segments = []
    count = 0
    for frame in ImageSequence.Iterator(im):
        print(f"Processing frame {count}")
        segs = process_frame(frame.convert("RGB"), args.width, args.height)
        frames_segments.append(segs)
        count += 1

    write_header(frames_segments, args.width, args.height, args.output, args.name)

if __name__ == "__main__":
    main()
